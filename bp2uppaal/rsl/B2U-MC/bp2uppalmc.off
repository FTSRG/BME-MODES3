.function find_first_statement
.param inst_ref p_mm_block_inst
	.select any mm_stmt_inst related by p_mm_block_inst->TE_BLK[R2016]->TE_SMT[R2014]
	.select one mm_prev_stmt_inst related by mm_stmt_inst->TE_SMT[R2012.'succeeds']
	.while(not_empty mm_prev_stmt_inst)
		.assign mm_stmt_inst = mm_prev_stmt_inst
		.select one mm_prev_stmt_inst related by mm_stmt_inst->TE_SMT[R2012.'succeeds']
	.end while
	.assign attr_result = mm_prev_stmt_inst
.end function
.//============================================================================
.function DecideIfStateMachineIsEmpty
.param inst_ref instance_sm_inst
.assign attr_isEmpty = FALSE
	.select many states related by instance_sm_inst->SM_SM[R517]->SM_STATE[R501]
	.if (empty states)
		.assign attr_isEmpty = TRUE
	.end if
.end function
.//============================================================================
.function GetAllEvents
.param inst_ref instance_sm_inst
	.select many events related by instance_sm_inst->SM_SM[R517]->SM_EVT[R502]
	.assign attr_result = events
.end function
.//============================================================================
.function findNonPolymorphicEvent
.param inst_ref instance_sm_inst
.param inst_ref event_inst
.assign attr_local = FALSE
.assign attr_declared = FALSE
	.select many evtLocal related by instance_sm_inst->SM_SM[R517]->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526] where (selected.SMevt_ID == event_inst.SMevt_ID)
	.assign nrLocal = cardinality evtLocal
	.select many evtDeclared related by instance_sm_inst->SM_SM[R517]->SM_EVT[R502]->SM_SEVT[R525] where (selected.SMevt_ID == event_inst.SMevt_ID)
	.assign nrDeclared = cardinality evtDeclared
	.if (nrLocal > 0)
	.assign attr_local = TRUE
	.end if
	.if (nrDeclared > 0)
	.assign attr_declared = TRUE
	.end if
.end function
.//============================================================================
.function GetStates
.param inst_ref instance_sm_inst
	.select many states related by instance_sm_inst->SM_SM[R517]->SM_STATE[R501]
	.assign attr_result = states
.end function
.//============================================================================
.function GetStateTransitions
.param inst_ref state_inst
.//Navigate across associations from state to outgoing transitions target state (through New State Transition ->State Event Matrix Entry)
	.select many transitions related by state_inst->SM_TXN[R506]->SM_NSTXN[R507]->SM_SEME[R504]
	.assign attr_result = transitions
.end function
.//============================================================================
.function GetStateTransitionName
.param inst_ref state_transition_inst
	.select one name related by state_transition_inst->SM_SEVT[R503]->SM_EVT[R525]
	.assign attr_result = name
.end function
.//============================================================================
.function GetStateTransitionAction
.param inst_ref state_transition_inst
	.select one action related by state_transition_inst->SM_NSTXN[R504]->SM_TXN[R507]->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514]
	.assign attr_result = action
.end function
.//============================================================================
.function GetClassNumberWithStates
.assign count = -1
.select many classes from instances of O_OBJ
.for each class in classes
.select many instance_state_machines from instances of SM_ISM where (selected.Obj_ID == class.Obj_ID)
	.for each instance_state_machine in instance_state_machines
.//Checking if instance state machine belongs to the current class.
.//If it does, navigate through the generalization of the instance state machine to the super SM_SM State Machine					
			.invoke stateSet = GetStates(instance_state_machine)
.//If it contains states create the UPPAAL location declaration					
			.if (not_empty stateSet.result)
				.assign count = count + 1
			.end if
	.end for
.end for
.assign attr_result = count
.end function
.//============================================================================
.function GenerateSystemBlock
.assign attr_result = "<system>system "
.invoke classNr = GetClassNumberWithStates()
.assign count = classNr.result
.select many classes from instances of O_OBJ
.for each class in classes
	.select many instance_state_machines from instances of SM_ISM where (selected.Obj_ID == class.Obj_ID)
	.for each instance_state_machine in instance_state_machines
.//If it does, navigate through the generalization of the instance state machine to the super SM_SM State Machine					
		.invoke stateSet = GetStates(instance_state_machine)
.//If it contains states create the UPPAAL location declaration					
			.if (not_empty stateSet.result)
.assign attr_result = attr_result + "${class.Name}"
				.if (count > 0)
.assign attr_result = attr_result + ","
				.assign count = count - 1
				.end if
			.end if
	.end for
.end for
.assign attr_result = attr_result + ";"
.assign attr_result = attr_result + "</system>"
.end function
.//============================================================================
.//============================================================================
.//BRIDGEPOINT 2 UPPAAL TRANSFORMATION
.//============================================================================
.select any system from instances of S_SYS
.select many components from instances of C_C
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd'>
<nta>
.assign dummyId = 0
.//============================================================================
.//DECLARATION block
		<declaration>
		.select many instance_state_machines from instances of SM_ISM
		.for each instance_state_machine in instance_state_machines
			.invoke eventSet = GetAllEvents(instance_state_machine)
			.assign events = eventSet.result
			.for each event in events
				.invoke evt = findNonPolymorphicEvent(instance_state_machine,event)
				.if (not evt.declared)
				broadcast chan ${event.Mning};
				.end if
				.if (evt.local)
				broadcast chan ${event.Mning};
				.end if
			.end for
		.end for
		</declaration>
.//============================================================================
.//TEMPLATE blocks
		.for each component in components
.//Selecting classes (Subsystem package - Model Class O_OBJ)
			.select many classes from instances of O_OBJ
			.for each class in classes
.//Selecting all instance state machines from system (State Machine package - Instance State Machine SM_ISM)
.//Checking if instance state machine belongs to the current class.
				.select many instance_state_machines from instances of SM_ISM where (selected.Obj_ID == class.Obj_ID)
				.for each instance_state_machine in instance_state_machines
					.invoke sm = DecideIfStateMachineIsEmpty(instance_state_machine)
.//If it contains states create the UPPAAL location declaration	
					.if (not sm.isEmpty)
						.create object instance init_ref of SM_STATE
							<template>
								<name>${class.Name}</name>
								<declaration></declaration>
								.invoke stateSet = GetStates(instance_state_machine)
								.assign states = stateSet.result
								.for each state in states
.//SMstt_ID - State machine state ID
									<location id="id${state.SMstt_ID}">
										<name>${state.Name}</name>
										.if (state.Name == "Init")
										.assign init_ref = state
										.end if
.//Navigating to the states' OAL statements: State->Moore Action Home->Action Home->Action								
										.select one action related by state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514]
										.//<label kind="comments">${action.Action_Semantics}</label>
										.select many statements related by action->ACT_SAB[R691]->ACT_ACT[R698]->ACT_BLK[R666]->ACT_SMT[R602] 
										.//->E_ESS[R603]->E_GES[R701]->E_GSME[R703]->E_GEN[R705]->V_VAR[R712]
										.//assign first_stmt = fs.result
										.for each statement in statements
										*****${statement.LineNumber}
										.end for	
										.if (last states)
										<committed/>
										.end if
									</location>
								.end for
								<init ref="id${init_ref.SMstt_ID}"/>
						.end if
.//Selecting all states of the related state machine through association R501 (State Machine States SM_STATE)
.//If it contains states create the UPPAAL location declaration	
						.invoke sm = DecideIfStateMachineIsEmpty(instance_state_machine)
						.if (not sm.isEmpty)
						.invoke stateSet = GetStates(instance_state_machine)
						.assign states = stateSet.result
						.for each state in states
							.invoke stateTransitionSet = GetStateTransitions(state)
							.assign stateTransitions = stateTransitionSet.result
							.for each stateTransition in stateTransitions
								.invoke stateTransitionAction = GetStateTransitionAction(stateTransition)
								.assign transitionAction = stateTransitionAction.result
								.if (transitionAction.Action_Semantics != "")
										-----${transitionAction.Action_Semantics}
								.select many statements related by transitionAction->ACT_TAB[R688]->ACT_ACT[R698]->ACT_BLK[R666]->ACT_SMT[R602]
								.for each statement in statements
										*****${statement.LineNumber}	
								.end for
									
									<location id="id${dummyId}">
										<name>dummy${dummyId}</name>
										<committed/>
									</location>
									<transition>
									<source ref="id${stateTransition.SMstt_ID}"/>
									<target ref="id${dummyId}"/>
									.invoke stateTransitionName = GetStateTransitionName(stateTransition)
									.assign transitionName = stateTransitionName.result
									<label kind="synchronisation">${transitionName.Mning}?</label>
									</transition>
									<transition>
									<source ref="id${dummyId}"/>
									<target ref="id${state.SMstt_ID}"/>
									</transition>
									.assign dummyId = dummyId + 1
								.else 
									<transition>
										<source ref="id${stateTransition.SMstt_ID}"/>
										<target ref="id${state.SMstt_ID}"/>
										.invoke stateTransitionName = GetStateTransitionName(stateTransition)
										.assign transitionName = stateTransitionName.result
										<label kind="synchronisation">${transitionName.Mning}?</label>
									</transition>
								.end if
							.end for
							.//Connect last state with init state
							.//<transition>
							.//<source ref="id${state.SMstt_ID}"/>
							.//<target ref="id${stateTransition.SMstt_ID}"/>
						.//</transition>
						.end for
						</template>	
					.end if	
				.end for
			.end for
.//============================================================================
.//SYSTEM block
.invoke systemBlock = GenerateSystemBlock()
${systemBlock.result}
.//============================================================================
</nta>
.emit to file "${component.Name}.xml"
.clear
.invoke SHELL_COMMAND("java -cp C:\Users\eraikon\WorkspaceLuna\XMLOrdering\bin validator.DTDValidator")
.end for


.//============================================================================
.// File:  sys_functions.arc
.//
.// Description:
.// This archetype file contains system level user definable archetype
.// functions.
.//
.// Notice:
.// (C) Copyright 1999-2010 Mentor Graphics Corporation
.//     All rights reserved.
.// Enhancements provided by TOYO Corporation.
.//============================================================================
.//
.//
.//============================================================================
.// *** Main Task utilities:
.//============================================================================
.//
.//============================================================================
.// GetMainTaskEntryDeclaration
.//
.// <Abstract>
.//  This function defines a main task entry.
.// <Input>
.// <Output>
.//  body:main function or main task entry
.// <Example>
.//  .function GetMainTaskEntryDeclaration
.//  void mainTask ( int taskId )
.//  .end function
.//============================================================================
.function GetMainTaskEntryDeclaration
  .select any te_target from instances of TE_TARGET
int
${te_target.main}( int argc, char ** argv )
.end function
.//
.//============================================================================
.// GetMainTaskEntryReturn
.//
.// <Abstract>
.//  This function defines return statements in a main function or 
.//  a main task entry.  If the main function has a non-void return
.//  type, a return statement should be defined.
.// <Input>
.// <Output>
.//  body:very last statements in main function or main task entry 
.// <Example>
.//  .function GetMainTaskEntryReturn
.//    return 0;
.//  .end function
.//============================================================================
.function GetMainTaskEntryReturn
  return 0;
.end function
.//
.//
.//============================================================================
.// fixing extents to a base address
.//============================================================================
.//
.//============================================================================
.// UserFixExtentBaseBegin
.//
.// <Abstract>
.//  This function gets called at the point just before the storage
.//  for the class extent (array of structures) is defined.
.//  Return a value used to ORG the object instance storage in memory.
.// <Input>
.//  BASE_ADDRESS information extracted from object description        
.// <Output>
.//  pragma or ORG statement to fix memory address for following define
.// <Example>
.//  .invoke UserFixExtentBaseBegin( base_address )
.//============================================================================
.function UserFixExtentBaseBegin
  .param string base_address
  .//
  .assign attr_result = "/* ${base_address} */"
.end function
.//
.//============================================================================
.// UserFixExtentBaseEnd
.//
.// <Abstract>
.//  This function gets called at the point just after the storage
.//  for the class extent (array of structures) is defined.
.//  Return a value used to complete the ORG the object instance storage.
.// <Input>
.//  BASE_ADDRESS information extracted from object description        
.// <Output>
.//  end pragma or blank
.// <Example>
.//  .invoke UserFixExtentBaseEnd( base_address )
.//============================================================================
.function UserFixExtentBaseEnd
  .param string base_address
  .//
  .assign attr_result = "/* ${base_address} */"
.end function
.//
.//
.//============================================================================
.// enabling/disabling interrupts
.//============================================================================
.//
.//============================================================================
.// UserEnableInterrupts
.//
.// <Abstract>
.//  This archetype function returns a string which represents
.//  the target instruction for enabling interrupts.
.// <Input>
.//  none
.// <Output>
.//  enable interrupts statement (or nothing)
.// <Example>
.//  .invoke UserEnableInterrupts()
.//============================================================================
.function UserEnableInterrupts
  .//
  .assign attr_result = "/* enable interrupts */"
.end function
.//
.//============================================================================
.// UserDisableInterrupts
.//
.// <Abstract>
.//  This archetype function returns a string which represents
.//  the target instruction for disabling interrupts.
.// <Input>
.//  none
.// <Output>
.//  disable interrupts statement (or nothing)
.// <Example>
.//  .invoke UserDisableInterrupts()
.//============================================================================
.function UserDisableInterrupts
  .//
  .assign attr_result = "/* disable interrupts */"
.end function
.//
.//
.//============================================================================
.// Do not add anything at the end of this file!
.//============================================================================
