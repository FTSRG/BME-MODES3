/*
 * generated by Xtext
 */
package hu.bme.mit.ftsrg.ptregex.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Alphabet;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Any;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Cardinality;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Choice;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Event;
import hu.bme.mit.ftsrg.ptregex.regularExpression.ExpressionDeclaration;
import hu.bme.mit.ftsrg.ptregex.regularExpression.FixIntParameter;
import hu.bme.mit.ftsrg.ptregex.regularExpression.FixStringParameter;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Functor;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Inverse;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Plus;
import hu.bme.mit.ftsrg.ptregex.regularExpression.RegexModel;
import hu.bme.mit.ftsrg.ptregex.regularExpression.RegularExpressionPackage;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Sequence;
import hu.bme.mit.ftsrg.ptregex.regularExpression.SingletonParameter;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Star;
import hu.bme.mit.ftsrg.ptregex.regularExpression.TimedExpression;
import hu.bme.mit.ftsrg.ptregex.regularExpression.Var;
import hu.bme.mit.ftsrg.ptregex.regularExpression.VarParameter;
import hu.bme.mit.ftsrg.ptregex.services.RegularExpressionGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RegularExpressionSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RegularExpressionGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == RegularExpressionPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case RegularExpressionPackage.ALPHABET:
				sequence_Alphabet(context, (Alphabet) semanticObject); 
				return; 
			case RegularExpressionPackage.ANY:
				sequence_Any(context, (Any) semanticObject); 
				return; 
			case RegularExpressionPackage.CARDINALITY:
				sequence_MultExpression(context, (Cardinality) semanticObject); 
				return; 
			case RegularExpressionPackage.CHOICE:
				sequence_Choice(context, (Choice) semanticObject); 
				return; 
			case RegularExpressionPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case RegularExpressionPackage.EXPRESSION_DECLARATION:
				sequence_ExpressionDeclaration(context, (ExpressionDeclaration) semanticObject); 
				return; 
			case RegularExpressionPackage.FIX_INT_PARAMETER:
				sequence_FixIntParameter(context, (FixIntParameter) semanticObject); 
				return; 
			case RegularExpressionPackage.FIX_STRING_PARAMETER:
				sequence_FixStringParameter(context, (FixStringParameter) semanticObject); 
				return; 
			case RegularExpressionPackage.FUNCTOR:
				sequence_Functor(context, (Functor) semanticObject); 
				return; 
			case RegularExpressionPackage.INVERSE:
				sequence_Inverse(context, (Inverse) semanticObject); 
				return; 
			case RegularExpressionPackage.PLUS:
				sequence_MultExpression(context, (Plus) semanticObject); 
				return; 
			case RegularExpressionPackage.REGEX_MODEL:
				sequence_RegexModel(context, (RegexModel) semanticObject); 
				return; 
			case RegularExpressionPackage.SEQUENCE:
				sequence_Sequence(context, (Sequence) semanticObject); 
				return; 
			case RegularExpressionPackage.SINGLETON_PARAMETER:
				sequence_SingletonParameter(context, (SingletonParameter) semanticObject); 
				return; 
			case RegularExpressionPackage.STAR:
				sequence_MultExpression(context, (Star) semanticObject); 
				return; 
			case RegularExpressionPackage.TIMED_EXPRESSION:
				sequence_TimedExpression(context, (TimedExpression) semanticObject); 
				return; 
			case RegularExpressionPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case RegularExpressionPackage.VAR_PARAMETER:
				sequence_VarParameter(context, (VarParameter) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     ((functors+=Functor functors+=Functor*)?)
	 */
	protected void sequence_Alphabet(EObject context, Alphabet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {Any}
	 */
	protected void sequence_Any(EObject context, Any semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=Choice_Choice_1_0 elements+=Sequence+)
	 */
	protected void sequence_Choice(EObject context, Choice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (functor=[Functor|ID] (parameters+=Parameter parameters+=Parameter*)?)
	 */
	protected void sequence_Event(EObject context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (vars+=Var vars+=Var*)? body=Expression)
	 */
	protected void sequence_ExpressionDeclaration(EObject context, ExpressionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     body=INT
	 */
	protected void sequence_FixIntParameter(EObject context, FixIntParameter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RegularExpressionPackage.Literals.FIX_INT_PARAMETER__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RegularExpressionPackage.Literals.FIX_INT_PARAMETER__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFixIntParameterAccess().getBodyINTTerminalRuleCall_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     body=STRING
	 */
	protected void sequence_FixStringParameter(EObject context, FixStringParameter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RegularExpressionPackage.Literals.FIX_STRING_PARAMETER__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RegularExpressionPackage.Literals.FIX_STRING_PARAMETER__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFixStringParameterAccess().getBodySTRINGTerminalRuleCall_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID arity=INT?)
	 */
	protected void sequence_Functor(EObject context, Functor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (excludes+=Event excludes+=Event*)
	 */
	protected void sequence_Inverse(EObject context, Inverse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (body=MultExpression_Cardinality_1_2_0 n=INT)
	 */
	protected void sequence_MultExpression(EObject context, Cardinality semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RegularExpressionPackage.Literals.CARDINALITY__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RegularExpressionPackage.Literals.CARDINALITY__BODY));
			if(transientValues.isValueTransient(semanticObject, RegularExpressionPackage.Literals.CARDINALITY__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RegularExpressionPackage.Literals.CARDINALITY__N));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMultExpressionAccess().getCardinalityBodyAction_1_2_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getMultExpressionAccess().getNINTTerminalRuleCall_1_2_2_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     body=MultExpression_Plus_1_1_0
	 */
	protected void sequence_MultExpression(EObject context, Plus semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RegularExpressionPackage.Literals.PLUS__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RegularExpressionPackage.Literals.PLUS__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMultExpressionAccess().getPlusBodyAction_1_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     body=MultExpression_Star_1_0_0
	 */
	protected void sequence_MultExpression(EObject context, Star semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RegularExpressionPackage.Literals.STAR__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RegularExpressionPackage.Literals.STAR__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMultExpressionAccess().getStarBodyAction_1_0_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (alphabet=Alphabet? declarations+=ExpressionDeclaration*)
	 */
	protected void sequence_RegexModel(EObject context, RegexModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=Sequence_Sequence_1_0 elements+=MultExpression+)
	 */
	protected void sequence_Sequence(EObject context, Sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {SingletonParameter}
	 */
	protected void sequence_SingletonParameter(EObject context, SingletonParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (body=Expression timeout=INT)
	 */
	protected void sequence_TimedExpression(EObject context, TimedExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RegularExpressionPackage.Literals.TIMED_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RegularExpressionPackage.Literals.TIMED_EXPRESSION__BODY));
			if(transientValues.isValueTransient(semanticObject, RegularExpressionPackage.Literals.TIMED_EXPRESSION__TIMEOUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RegularExpressionPackage.Literals.TIMED_EXPRESSION__TIMEOUT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimedExpressionAccess().getBodyExpressionParserRuleCall_1_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getTimedExpressionAccess().getTimeoutINTTerminalRuleCall_4_0(), semanticObject.getTimeout());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     var=[Var|ID]
	 */
	protected void sequence_VarParameter(EObject context, VarParameter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RegularExpressionPackage.Literals.VAR_PARAMETER__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RegularExpressionPackage.Literals.VAR_PARAMETER__VAR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVarParameterAccess().getVarVarIDTerminalRuleCall_0_1(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Var(EObject context, Var semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, RegularExpressionPackage.Literals.VAR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RegularExpressionPackage.Literals.VAR__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVarAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
}
